/*
@brief PoET leader selection demo (for my master student)
@author Sergey Staroletov serg_soft@mail.ru https://www.researchgate.net/profile/Sergey_Staroletov
@license GNU GPL
*/


#define P 5

chan SGX=[0] of {short}; //канал для генерации случайного числа

mtype  = {STATE_INIT, STATE_GEN, STATE_WAITING, STATE_MINEBLOCK, STATE_NOMINEBLOCK};
mtype state = STATE_INIT; //глобальное состояние сети
mtype procStates[P]; //состояния узлов сети

short procTimes[P]; //время ожидания узлов

bool isGenerating = false;
byte generator;  //процесс-генератор последнего блока

short Nblock = 0; //количество блоков


ltl willBeGenerated { <> (Nblock > 0) };

ltl checkFor0 { [] (isGenerating && (generator == 0) ->  procTimes[0] <= procTimes[1] && procTimes[0] <= procTimes[2] && procTimes[0] <= procTimes[3] && procTimes[0] <= procTimes[4] 
&& procStates[0]==STATE_MINEBLOCK && procStates[1]==STATE_NOMINEBLOCK && procStates[2]==STATE_NOMINEBLOCK && procStates[3]==STATE_NOMINEBLOCK && procStates[4]==STATE_NOMINEBLOCK)
};




active proctype processor() {  
byte buf;
short nr;	
do
:: {
    SGX ? buf;
	do
        :: (nr < 32768) -> nr++;
        :: (nr > 0) -> nr--;		
	:: break
	od;
    SGX ! nr;
}
od
}


proctype proc(byte N) {
do
:: {
    //ждем следующего цикла - состояния STATE_INIT
        do  
            :: (state == STATE_INIT) -> break;
            :: else -> skip;
        od

        procStates[N] = STATE_GEN;
        //сгенерировать случайное число - запросить у процессора 
        short nr = 0;
        SGX ! 1;
        SGX ? nr;
        procTimes[N] = nr;
        printf("Process pid = %d  got nr = %d \n", _pid, nr);
        procStates[N] = STATE_WAITING;

        //эмулировать ожидание - в цикле уменьшать переменную заданное количество раз
        short count = nr;
        do 
            :: (count >= 0) -> count--; 
            :: else -> break;
        od

        //после ожидания проверить, нет ли блока и попытаться его сгенерировать
        bool ifOurBlock = false;
        if 
            :: (state != STATE_MINEBLOCK) -> {
                //еще нету, раз мы первые, то помечаем себя лидером
                atomic {
                    state = STATE_MINEBLOCK; //мы поменяли, если другие не успели
                    procStates[N] = STATE_MINEBLOCK; //помечаем, что блок наш
                    ifOurBlock = true; 
                }
                if  //в других случаях  -  блок не наш
                    ::(procStates[N] != STATE_MINEBLOCK) -> procStates[N] = STATE_NOMINEBLOCK; 
                    ::else -> skip;
                fi
            }
            :: else -> procStates[N] = STATE_NOMINEBLOCK;
        fi
        //далее логика по генерации блока, если условия выполнены
        if 
            :: ifOurBlock == true -> {
                //мы думаем, что мы лидер - ждать все остальные процессы
                do 
                :: {
                    count = P - 1;
                    short countReady = 0; 
                    short countLeaders = 0; 
                    do
                        :: (count >= 0) -> {
                            if
                                //считаем количество процессов не лидеров
                                :: (procStates[count] == STATE_NOMINEBLOCK) || 
                                //а также новые процессы
                                (procStates[count] ==  STATE_INIT) -> {
                                    countReady++; 
                                }
                                //считаем количество лидеров
                                :: (procStates[count] == STATE_MINEBLOCK) -> countLeaders++;
                                :: else ->  skip;
                            fi
                            count--;
                        }
                        :: else -> break;
                    od
                    if :: (countReady == P - 1) ->  //нормальное состояние - я лидер и других нет
                    {
                        isGenerating = true;
                        generator = N;
                        Nblock++;
                        printf("BLOCK %d generated by process %d! \n", Nblock, _pid);
                        isGenerating = false;
                        break;
                    }
                    :: (countLeaders != 1) -> { //что-то не так, несколько лидеров - перевыборы
                        printf("REELECTION! \n");
                            break;
                    }
                    :: else -> skip;
                    fi
                } od
                //инициировать новый раунд
                state = STATE_INIT;
                printf("NEW ROUND INITIATED BY %d \n", _pid);
            }
            ::else -> 
            skip;
        fi
    }
od
} 


active proctype main() {
    state = STATE_WAITING;
    short count = P - 1;
    do
        :: (count >= 0) -> {
            procStates[count] = STATE_INIT;
            run proc(count);
            count--;
        }
        :: else -> break;
    od
    state = STATE_INIT;
}


